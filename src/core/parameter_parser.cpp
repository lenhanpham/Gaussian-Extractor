/**
 * @file parameter_parser.cpp
 * @brief Implementation of parameter file parsing functionality
 * @author Le Nhan Pham
 * @date 2025
 *
 * This file contains the implementation of the ParameterParser class
 * for reading and writing parameter files.
 */

#include "parameter_parser.h"
#include "utils.h"
#include <algorithm>
#include <filesystem>
#include <fstream>
#include <iostream>
#include <sstream>

ParameterParser::ParameterParser() {}

bool ParameterParser::loadFromFile(const std::string& filename)
{
    std::ifstream file(filename);
    if (!file.is_open())
    {
        std::cerr << "Error: Cannot open parameter file: " << filename << std::endl;
        return false;
    }

    std::vector<std::string> lines;
    std::string              line;
    while (std::getline(file, line))
    {
        lines.push_back(line);
    }
    file.close();

    parameters_.clear();

    for (size_t i = 0; i < lines.size(); ++i)
    {
        std::string key, value;
        if (parseLine(lines[i], key, value))
        {
            // Check if this is the start of a multi-line value
            if (!value.empty() && value.back() == '\\')
            {
                // Remove the backslash and continue reading
                value = value.substr(0, value.size() - 1);
                value += parseMultiLineValue(lines, ++i);
            }
            // Special handling for tail parameter which may be multi-line
            else if (key == "tail" && value.empty())
            {
                value = parseMultiLineParameter(lines, i);
            }
            // Special handling for modre parameter which may be multi-line
            else if (key == "modre" && value.empty())
            {
                value = parseMultiLineParameter(lines, i);
            }
            // Special handling for extra_options parameters in the extra_options part which may be multi-line
            else if (key == "extra_options" && value.empty())
            {
                value = parseMultiLineParameter(lines, i);
            }
            parameters_[key] = value;
        }
    }

    return true;
}

bool ParameterParser::saveToFile(const std::string& filename) const
{
    std::ofstream file(filename);
    if (!file.is_open())
    {
        std::cerr << "Error: Cannot create parameter file: " << filename << std::endl;
        return false;
    }

    file << "# Parameter file for Gaussian input creation\n";
    file << "# Generated by Gaussian Extractor\n";
    file << "# Lines starting with # are comments\n\n";

    for (const auto& [key, value] : parameters_)
    {
        file << key << " = " << value << "\n";
    }

    file.close();
    return true;
}

std::string ParameterParser::getString(const std::string& key, const std::string& default_value) const
{
    auto it = parameters_.find(key);
    return (it != parameters_.end()) ? it->second : default_value;
}

int ParameterParser::getInt(const std::string& key, int default_value) const
{
    auto it = parameters_.find(key);
    if (it != parameters_.end())
    {
        try
        {
            return std::stoi(it->second);
        }
        catch (const std::exception&)
        {
            return default_value;
        }
    }
    return default_value;
}

bool ParameterParser::getBool(const std::string& key, bool default_value) const
{
    auto it = parameters_.find(key);
    if (it != parameters_.end())
    {
        std::string value = it->second;
        std::transform(value.begin(), value.end(), value.begin(), ::tolower);
        return (value == "true" || value == "yes" || value == "1");
    }
    return default_value;
}

void ParameterParser::setString(const std::string& key, const std::string& value)
{
    parameters_[key] = value;
}

void ParameterParser::setInt(const std::string& key, int value)
{
    parameters_[key] = std::to_string(value);
}

void ParameterParser::setBool(const std::string& key, bool value)
{
    parameters_[key] = value ? "true" : "false";
}

bool ParameterParser::hasParameter(const std::string& key) const
{
    return parameters_.find(key) != parameters_.end();
}

bool ParameterParser::generateTemplate(const std::string& calc_type, const std::string& filename) const
{
    std::string content = createTemplateContent(calc_type);
    if (content.empty())
    {
        std::cerr << "Error: Unknown calculation type: " << calc_type << std::endl;
        return false;
    }

    // Create directory if it doesn't exist
    std::filesystem::path file_path(filename);
    std::filesystem::path dir_path = file_path.parent_path();
    if (!dir_path.empty() && !std::filesystem::exists(dir_path))
    {
        try
        {
            std::filesystem::create_directories(dir_path);
        }
        catch (const std::filesystem::filesystem_error& e)
        {
            std::cerr << "Error: Cannot create directory " << dir_path.string() << ": " << e.what() << std::endl;
            return false;
        }
    }

    std::ofstream file(filename);
    if (!file.is_open())
    {
        std::cerr << "Error: Cannot create template file: " << filename << std::endl;
        return false;
    }

    file << content;
    file.close();

    std::cout << "Template file created: " << filename << std::endl;
    return true;
}

bool ParameterParser::generateAllTemplates(const std::string& directory) const
{
    // Create directory if it doesn't exist
    std::filesystem::path dir_path(directory);
    try
    {
        if (!std::filesystem::exists(dir_path))
        {
            std::filesystem::create_directories(dir_path);
        }
    }
    catch (const std::filesystem::filesystem_error& e)
    {
        std::cerr << "Error: Cannot create directory " << directory << ": " << e.what() << std::endl;
        return false;
    }

    std::vector<std::string> calc_types   = getSupportedCalcTypes();
    std::filesystem::path    abs_dir_path = std::filesystem::absolute(dir_path);

    std::cout << "Generating " << calc_types.size() << " specific template files and 1 general template file..."
              << std::endl;

    // Generate the general template file first
    std::filesystem::path general_base_path  = dir_path / "ci_parameters.params";
    std::filesystem::path general_final_path = Utils::generate_unique_filename(general_base_path);
    if (!generateGeneralTemplate(general_final_path.string()))
    {
        return false;
    }

    // Generate specific templates for each calculation type
    for (const auto& calc_type : calc_types)
    {
        std::filesystem::path base_path  = dir_path / (calc_type + ".params");
        std::filesystem::path final_path = Utils::generate_unique_filename(base_path);
        if (!generateTemplate(calc_type, final_path.string()))
        {
            return false;
        }
    }

    std::cout << "All " << calc_types.size() << " specific template files and 1 general template file "
              << "generated successfully in: " << abs_dir_path.string() << std::endl;
    return true;
}

bool ParameterParser::generateGeneralTemplate(const std::string& filename) const
{
    std::string content = createGeneralTemplateContent();
    if (content.empty())
    {
        std::cerr << "Error: Failed to create general template content" << std::endl;
        return false;
    }

    // Create directory if it doesn't exist
    std::filesystem::path file_path(filename);
    std::filesystem::path dir_path = file_path.parent_path();
    if (!dir_path.empty() && !std::filesystem::exists(dir_path))
    {
        try
        {
            std::filesystem::create_directories(dir_path);
        }
        catch (const std::filesystem::filesystem_error& e)
        {
            std::cerr << "Error: Cannot create directory " << dir_path.string() << ": " << e.what() << std::endl;
            return false;
        }
    }

    std::ofstream file(filename);
    if (!file.is_open())
    {
        std::cerr << "Error: Cannot create general template file: " << filename << std::endl;
        return false;
    }

    file << content;
    file.close();

    std::cout << "General template file created: " << filename << std::endl;
    return true;
}

std::vector<std::string> ParameterParser::getSupportedCalcTypes() const
{
    return {"sp",
            "opt_freq",
            "ts_freq",
            "oss_ts_freq",
            "modre_ts_freq",
            "modre_opt",
            "oss_check_sp",
            "high_sp",
            "irc_forward",
            "irc_reverse"};
}

void ParameterParser::clear()
{
    parameters_.clear();
}

std::string ParameterParser::trim(const std::string& str) const
{
    size_t first = str.find_first_not_of(" \t\r\n");
    if (first == std::string::npos)
        return "";

    size_t last = str.find_last_not_of(" \t\r\n");
    return str.substr(first, last - first + 1);
}

bool ParameterParser::parseLine(const std::string& line, std::string& key, std::string& value)
{
    std::string trimmed = trim(line);

    // Skip empty lines and comments
    if (trimmed.empty() || trimmed[0] == '#')
    {
        return false;
    }

    // Find the equals sign
    size_t equals_pos = trimmed.find('=');
    if (equals_pos == std::string::npos)
    {
        return false;
    }

    key   = trim(trimmed.substr(0, equals_pos));
    value = trim(trimmed.substr(equals_pos + 1));

    return true;
}

std::string ParameterParser::parseMultiLineValue(const std::vector<std::string>& lines, size_t& start_index)
{
    std::string result;
    bool        continue_parsing = true;

    while (start_index < lines.size() && continue_parsing)
    {
        std::string line    = lines[start_index];
        std::string trimmed = trim(line);

        // Check if this line continues the multi-line value
        if (!trimmed.empty() && trimmed.back() == '\\')
        {
            // Remove backslash and add newline
            result += trimmed.substr(0, trimmed.size() - 1) + "\n";
        }
        else if (!trimmed.empty() && trimmed[0] != '#')
        {
            // This is the last line of the multi-line value
            result += trimmed;
            continue_parsing = false;
        }
        else if (trimmed.empty())
        {
            // Empty line ends multi-line value
            continue_parsing = false;
        }
        else
        {
            // Comment line, skip
        }

        start_index++;
    }

    return result;
}

std::string ParameterParser::createTemplateContent(const std::string& calc_type) const
{
    // Validate calculation type
    std::vector<std::string> valid_types = {"sp",
                                            "opt_freq",
                                            "ts_freq",
                                            "oss_ts_freq",
                                            "oss_check_sp",
                                            "high_sp",
                                            "irc_forward",
                                            "irc_reverse",
                                            "irc",
                                            "modre_ts_freq",
                                            "modre_opt"};

    bool is_valid = false;
    for (const auto& type : valid_types)
    {
        if (type == calc_type)
        {
            is_valid = true;
            break;
        }
    }

    if (!is_valid)
    {
        return "";  // Invalid calculation type
    }

    std::ostringstream content;

    content << "# Parameter file for Gaussian input creation\n";
    content << "# Calculation type: " << calc_type << "\n";
    content << "# Generated by Gaussian Extractor\n";
    content << "# Lines starting with # are comments\n\n";

    // Common parameters
    content << "# Basic parameters\n";
    content << "calc_type = " << calc_type << "\n";
    content << "functional = UWB97XD\n";
    content << "basis = def2SVPP\n";
    content << "charge = 0\n";
    content << "mult = 1\n";
    content << "extension = .gau\n\n";

    // Solvent parameters
    content << "# Solvent parameters (optional)\n";
    content << "# solvent = water\n";
    content << "# solvent_model = smd\n\n";

    // Calculation-specific parameters
    if (calc_type == "ts_freq" || calc_type == "oss_ts_freq" || calc_type == "modre_ts_freq" ||
        calc_type == "high_sp" || calc_type == "irc_forward")
    {
        content << "# Large basis set (required for TS/high-level calculations)\n";
        content << "large_basis = def2TZVPP\n\n";
    }

    if (calc_type == "oss_ts_freq" || calc_type == "modre_ts_freq" || calc_type == "modre_opt")
    {
        content << "# Freeze atoms for TS (1-based indices)\n";
        content << "# freeze_atoms = 1,2\n\n";
        content << "# Modredundant section (alternative to freeze_atoms)\n";
        content << "# modre =\n";
        content << "# B 1 2 F\n";
        content << "# A 1 2 3 F\n";
        content << "#\n";
        content << "# Or use punctuation marks to preserve blank lines:\n";
        content << "# modre =\n";
        content << "# (\n";
        content << "# B 1 2 F\n";
        content << "# \n";
        content << "# A 1 2 3 F\n";
        content << "# )\n\n";
    }

    if (calc_type == "high_sp" || calc_type == "irc_forward" || calc_type == "irc_reverse")
    {
        content << "# TS checkpoint path (default: parent directory)\n";
        content << "# tschk_path = ../ts_checkpoints\n\n";
    }

    // Advanced parameters
    content << "# print_level = P\n";
    content << "# route_extra_keywords = Int=UltraFine SCF=Conver=8\n";
    content << "# Or with delimiters: Int=UltraFine, SCF=Conver=8; Opt=Loose\n\n";

    // Custom cycle and optimization parameters
    content << "# Custom cycle and optimization parameters (optional)\n";
    content << "# Override defaults for SCF, OPT, IRC keywords\n";
    int default_scf = (calc_type == "sp" || calc_type == "opt_freq" || calc_type == "high_sp") ? 500 : 300;
    content << "# scf_maxcycle = " << default_scf << "\n";
    if (calc_type == "opt_freq" || calc_type == "ts_freq" || calc_type == "oss_ts_freq" ||
        calc_type == "modre_ts_freq" || calc_type == "modre_opt")
    {
        content << "# opt_maxcycles = 300\n";
    }
    if (calc_type.find("irc") != std::string::npos)
    {
        content << "# irc_maxpoints = 50\n";
        content << "# irc_recalc = 10\n";
        content << "# irc_maxcycle = 350\n";
        content << "# irc_stepsize = 10\n";
    }
    content << "\n";

    // Multi-line tail example (only for calc types that support GEN/GENECP)
    if (calc_type == "sp" || calc_type == "opt_freq" || calc_type == "ts_freq" || calc_type == "oss_ts_freq" ||
        calc_type == "oss_check_sp" || calc_type == "modre_ts_freq" || calc_type == "modre_opt" ||
        calc_type == "high_sp" || calc_type == "irc_forward" || calc_type == "irc_reverse" || calc_type == "irc")
    {
        content << "# Multi-line tail (for custom basis sets, etc.)\n";
        content << "# tail = \n";
        content << "# additional lines of keywords\n";
        content << "# additional lines of keywords\n";
        content << "# additional lines of keywords\n";
        content << "#\n";
        content << "# Or use punctuation marks to preserve blank lines:\n";
        content << "# tail =\n";
        content << "# (\n";
        content << "# additional lines of keywords\n";
        content << "# \n";
        content << "# additional lines of keywords\n";
        content << "# additional lines of keywords\n";
        content << "# )\n\n";
    }

    // Multi-line extra_options example (optional for all calc types)
    content << "# Multi-line extra_options section (for additional input sections, etc.)\n";
    content << "# extra_options = \n";
    content << "# Additional keywords or sections here\n";
    content << "#\n";
    content << "# Or use punctuation marks to preserve blank lines:\n";
    content << "# extra_options =\n";
    content << "# (\n";
    content << "# Additional keywords\n";
    content << "# \n";
    content << "# More sections\n";
    content << "# )\n\n";

    return content.str();
}

std::string ParameterParser::createGeneralTemplateContent() const
{
    std::ostringstream content;

    content << "# General parameter file for Gaussian input creation\n";
    content << "# This file contains all possible parameters for all calculation types\n";
    content << "# Generated by Gaussian Extractor\n";
    content << "# Lines starting with # are comments\n";
    content << "# Only relevant parameters will be used based on the calculation type\n\n";

    // Basic parameters (used by all calculation types)
    content << "# ==========================================\n";
    content << "# BASIC PARAMETERS (used by all calc types)\n";
    content << "# ==========================================\n";
    content << "calc_type = opt_freq\n";
    content << "functional = UWB97XD\n";
    content << "basis = def2SVPP\n";
    content << "charge = 0\n";
    content << "mult = 1\n";
    content << "extension = .gau\n\n";

    // Solvent parameters (used by most calculation types)
    content << "# ==========================================\n";
    content << "# SOLVENT PARAMETERS (optional)\n";
    content << "# ==========================================\n";
    content << "# solvent = water\n";
    content << "# solvent_model = smd\n\n";

    // TS-specific parameters (used by TS calculations)
    content << "# ==========================================\n";
    content << "# TS-SPECIFIC PARAMETERS\n";
    content << "# (used by ts_freq, oss_ts_freq, modre_ts_freq)\n";
    content << "# ==========================================\n";
    content << "# large_basis = def2TZVPP\n";
    content << "# freeze_atoms = 1,2\n";
    content << "# freeze_atom1 = 1\n";
    content << "# freeze_atom2 = 2\n";
    content << "# modre =\n";
    content << "# B 1 2 F\n";
    content << "# A 1 2 3 F\n";
    content << "#\n";
    content << "# Or use punctuation marks to preserve blank lines for multiple parts of keywords\n";
    content << "# modre =\n";
    content << "# (\n";
    content << "# B 1 2 F\n";
    content << "# \n";
    content << "# A 1 2 3 F\n";
    content << "# )\n\n";

    // High-level calculation parameters (used by high_sp, IRC)
    content << "# ==========================================\n";
    content << "# HIGH-LEVEL CALCULATION PARAMETERS\n";
    content << "# (used by high_sp, irc_forward, irc_reverse)\n";
    content << "# ==========================================\n";
    content << "# tschk_path = ../ts_checkpoints\n\n";

    // Advanced parameters (used by all calculation types)
    content << "# ==========================================\n";
    content << "# ADVANCED PARAMETERS (used by all calc types)\n";
    content << "# ==========================================\n";
    content << "# print_level = P\n";
    content << "# route_extra_keywords = Int=UltraFine SCF=Conver=8\n";
    content << "# Supports multiple keywords separated by spaces, commas, or semicolons\n\n";

    // Custom cycle and optimization parameters
    content << "# ==========================================\n";
    content << "# CUSTOM CYCLE AND OPTIMIZATION PARAMETERS (optional)\n";
    content << "# Override defaults for SCF, OPT, IRC keywords\n";
    content << "# scf_maxcycle = 500  # Default 500 for SP/OPT_FREQ/HIGH_SP, 300 for others\n";
    content << "# opt_maxcycles = 300\n";
    content << "# irc_maxpoints = 50\n";
    content << "# irc_recalc = 10\n";
    content << "# irc_maxcycle = 350\n";
    content << "# irc_stepsize = 10\n\n";

    // Multi-line tail example
    content << "# ==========================================\n";
    content << "# MULTI-LINE TAIL (for custom basis sets, etc.)\n";
    content << "# ==========================================\n";
    content << "# tail = \n";
    content << "# additional lines of keywords\n";
    content << "# additional lines of keywords\n";
    content << "# additional lines of keywords\n";
    content << "#\n";
    content << "# Or use punctuation marks to preserve blank lines:\n";
    content << "# tail =\n";
    content << "# (\n";
    content << "# additional lines of keywords\n";
    content << "# \n";
    content << "# additional lines of keywords\n";
    content << "# additional lines of keywords\n";
    content << "# )\n\n";

    // Multi-line extra_options example
    content << "# ==========================================\n";
    content << "# MULTI-LINE EXTRA_KEYWORD (for additional input sections)\n";
    content << "# ==========================================\n";
    content << "# extra_options = \n";
    content << "# Additional keywords or sections here\n";
    content << "#\n";
    content << "# Or use punctuation marks to preserve blank lines:\n";
    content << "# extra_options =\n";
    content << "# (\n";
    content << "# Additional keywords\n";
    content << "# \n";
    content << "# More sections\n";
    content << "# )\n\n";

    // Usage examples
    content << "# ==========================================\n";
    content << "# USAGE EXAMPLES\n";
    content << "# ==========================================\n";
    content << "#\n";
    content << "# For single point energy:\n";
    content << "#   calc_type = sp\n";
    content << "#\n";
    content << "# For optimization + frequency:\n";
    content << "#   calc_type = opt_freq\n";
    content << "#\n";
    content << "# For transition state search:\n";
    content << "#   calc_type = ts_freq\n";
    content << "#   large_basis = def2TZVPP\n";
    content << "#\n";
    content << "# For high-level single point:\n";
    content << "#   calc_type = high_sp\n";
    content << "#   large_basis = def2TZVPP\n";
    content << "#   tschk_path = ../ts_checkpoints\n";
    content << "#\n";
    content << "# For IRC calculations:\n";
    content << "#   calc_type = irc_forward\n";
    content << "#   large_basis = def2TZVPP\n";
    content << "#   tschk_path = ../ts_checkpoints\n\n";

    return content.str();
}

/**
 * @brief Parse multi-line parameter content with support for punctuation marks
 * @param lines Vector of file lines
 * @param start_index Starting index (will be updated to skip processed lines)
 * @return Parsed multi-line content
 */
std::string ParameterParser::parseMultiLineParameter(const std::vector<std::string>& lines, size_t& start_index)
{
    size_t i = start_index + 1;  // Start from the line after the parameter declaration

    // Check if the next line starts with punctuation marks
    if (i < lines.size())
    {
        std::string first_line   = trim(lines[i]);
        char        opening_mark = '\0';
        char        closing_mark = '\0';

        // Detect punctuation marks
        if (!first_line.empty())
        {
            if (first_line[0] == '(')
            {
                opening_mark = '(';
                closing_mark = ')';
            }
            else if (first_line[0] == '[')
            {
                opening_mark = '[';
                closing_mark = ']';
            }
            else if (first_line[0] == '{')
            {
                opening_mark = '{';
                closing_mark = '}';
            }
            else if (first_line[0] == '<')
            {
                opening_mark = '<';
                closing_mark = '>';
            }
        }

        if (opening_mark != '\0')
        {
            // Parse content between punctuation marks
            std::string content;
            bool        found_closing = false;
            size_t      j             = i;

            // Find the matching closing mark
            while (j < lines.size())
            {
                std::string line        = lines[j];
                size_t      closing_pos = line.find(closing_mark);

                if (closing_pos != std::string::npos)
                {
                    // Found closing mark - extract content up to this point
                    if (j == i)
                    {
                        // Opening and closing marks on the same line
                        // Extract content between marks exactly as is
                        content = line.substr(1, closing_pos - 1);
                    }
                    else
                    {
                        // Multi-line content
                        for (size_t k = i; k < j; ++k)
                        {
                            std::string line_content;
                            if (k == i)
                            {
                                // First line: find and remove opening mark
                                size_t mark_pos = lines[k].find(opening_mark);
                                if (mark_pos != std::string::npos)
                                {
                                    // Extract content after the opening mark
                                    line_content = lines[k].substr(mark_pos + 1);
                                }
                            }
                            else
                            {
                                // Other lines: use as-is
                                line_content = lines[k];
                            }

                            // Always add the line, even if empty (to preserve blank lines)
                            if (!content.empty() || k > i)
                            {
                                content += "\n";
                            }
                            content += line_content;
                        }

                        // Handle the line with closing mark
                        std::string closing_line_content = line.substr(0, closing_pos);
                        // Remove trailing whitespace
                        size_t last_non_ws = closing_line_content.find_last_not_of(" \t\r\n");
                        if (last_non_ws != std::string::npos)
                        {
                            closing_line_content = closing_line_content.substr(0, last_non_ws + 1);
                        }
                        else
                        {
                            closing_line_content = "";
                        }

                        // Always add the closing line content, even if empty
                        content += "\n";
                        content += closing_line_content;
                    }
                    found_closing = true;
                    start_index   = j;  // Update start_index to skip processed lines
                    break;
                }
                j++;
            }

            if (!found_closing)
            {
                throw std::runtime_error("Missing closing punctuation mark '" + std::string(1, closing_mark) +
                                         "' for multi-line parameter");
            }

            return content;
        }
    }

    // Fallback to original parsing logic (no punctuation marks)
    std::string content;
    size_t      j = i;  // Start from the parameter declaration line
    while (j < lines.size())
    {
        std::string next_line = trim(lines[j]);
        if (next_line.empty() || next_line[0] == '#')
        {
            // Empty line or comment ends the section
            break;
        }
        // Skip the parameter declaration line itself
        if (j == start_index)
        {
            j++;
            continue;
        }
        if (!content.empty())
        {
            content += "\n";
        }
        content += lines[j];  // Keep original formatting
        j++;
    }
    start_index = j - 1;  // Skip the lines we processed
    return content;
}