/**
 * @file main.cpp
 * @brief Main entry point for the Gaussian Extractor application
 * @author Le Nhan Pham
 * @date 2025
 *
 * This file contains the main function and signal handling for the Gaussian Extractor,
 * a high-performance tool for processing Gaussian computational chemistry log files.
 * The application supports various commands including extraction, job checking, and
 * high-level energy calculations.
 *
 * @section Features
 * - Multi-threaded file processing with resource management
 * - Job scheduler integration (SLURM, PBS, SGE, LSF)
 * - Comprehensive error detection and job status checking
 * - High-level energy calculations with thermal corrections
 * - Configurable through configuration files and command-line options
 * - Graceful shutdown handling for long-running operations
 */

#include "core/command_system.h"
#include "core/config_manager.h"
#include "core/gaussian_extractor.h"
#include "core/job_scheduler.h"
#include "core/module_executor.h"
#include <cstring>
#include <atomic>
#include <csignal>
#include <iostream>
#include <limits>
#include <sstream>
#include <string>
#include <thread>
#include <vector>

/**
 * @brief Global flag to indicate when a shutdown has been requested
 *
 * This atomic boolean is used to coordinate graceful shutdown across all threads
 * when a termination signal (SIGINT, SIGTERM) is received. All long-running
 * operations should periodically check this flag and terminate cleanly.
 */
std::atomic<bool> g_shutdown_requested{false};

/**
 * @brief Signal handler for graceful shutdown
 *
 * This function is called when the application receives termination signals
 * (SIGINT from Ctrl+C, SIGTERM from system shutdown, etc.). It sets the global
 * shutdown flag to coordinate clean termination of all threads and operations.
 *
 * @param signal The signal number that was received
 *
 * @note This function is signal-safe and only performs async-signal-safe operations
 * @see g_shutdown_requested
 */
void signalHandler(int signal)
{
    std::cerr << "\nReceived signal " << signal << ". Initiating graceful shutdown..." << std::endl;
    g_shutdown_requested.store(true);
}

/**
 * @brief Interactive command loop for Windows double-click usage
 *
 * This function provides an interactive shell where users can enter commands
 * after the initial EXTRACT operation. It reads commands from stdin and
 * processes them using the existing command parsing system.
bool is_shell_command(const std::string& cmd);
 *
 * @return Exit code when the interactive loop terminates
 */
int run_interactive_loop()
{
    std::cout << "
Gaussian Extractor Interactive Mode" << std::endl;
    std::cout << "Type 'help' for available commands, 'exit' or 'quit' to exit." << std::endl;
    std::cout << "You can also use shell commands like 'cd', 'ls', etc." << std::endl;
    std::cout << ">> ";

    std::string line;
    while (std::getline(std::cin, line))
    {
        // Trim whitespace
        size_t start = line.find_first_not_of(" 	");
        if (start != std::string::npos) {
            line.erase(0, start);
        } else {
            line.clear();
        }
        size_t end = line.find_last_not_of(" 	");
        if (end != std::string::npos) {
            line.erase(end + 1);
        }

        if (line.empty())
        {
            std::cout << ">> ";
            continue;
        }

        if (line == "exit" || line == "quit")
        {
            std::cout << "Exiting Gaussian Extractor. Goodbye!" << std::endl;
            return 0;
        }

        // Handle special commands that would normally exit
        if (line == "help" || line == "--help" || line == "-h")
        {
            std::cout << "
Available commands:" << std::endl;
            std::cout << "  extract           Extract thermodynamic data from log files" << std::endl;
            std::cout << "  done              Check and organize completed jobs" << std::endl;
            std::cout << "  errors            Check and organize failed jobs" << std::endl;
            std::cout << "  pcm               Check PCM convergence failures" << std::endl;
            std::cout << "  imode             Check jobs with imaginary frequencies" << std::endl;
            std::cout << "  check             Run all job checks" << std::endl;
            std::cout << "  high-kj           Calculate high-level energies in kJ/mol" << std::endl;
            std::cout << "  high-au           Calculate high-level energies in atomic units" << std::endl;
            std::cout << "  xyz               Extract coordinates to XYZ format" << std::endl;
            std::cout << "  help              Show this help message" << std::endl;
            std::cout << "  --version         Show version information" << std::endl;
            std::cout << "  --config-help     Show configuration help" << std::endl;
            std::cout << "  --create-config   Create default configuration file" << std::endl;
            std::cout << "  --show-config     Show current configuration" << std::endl;
            std::cout << "
You can use command-line options with any command." << std::endl;
            std::cout << "Example: extract -q -nt 4" << std::endl;
            std::cout << "
You can also use shell commands like 'cd', 'ls', 'pwd', etc." << std::endl;
        }
        else if (line == "--version" || line == "-v")
        {
            std::cout << GaussianExtractor::get_version_info() << std::endl;
        }
        else if (line == "--config-help")
        {
            CommandParser::print_config_help();
        }
        else if (line == "--create-config")
        {
            CommandParser::create_default_config();
        }
        else if (line == "--show-config")
        {
            g_config_manager.print_config_summary(true);
        }
        else if (is_shell_command(line))
        {
            // Execute as shell command
            int result = std::system(line.c_str());
            if (result != 0)
            {
                std::cout << "Command exited with code: " << result << std::endl;
            }
        }
        else
        {
            // Parse and execute as Gaussian command
            try
            {
                // Split the line into arguments
                std::vector<char*> args;
                std::string arg;
                std::istringstream iss(line);
                args.push_back(const_cast<char*>("gaussian_extractor"));  // Program name

                while (iss >> arg)
                {
                    char* cstr = new char[arg.size() + 1];
                    strcpy(cstr, arg.c_str());
                    args.push_back(cstr);
                }

                if (args.size() > 1)
                {
                    // Parse the command
                    CommandContext context = CommandParser::parse(args.size(), args.data());

                    // Show warnings if any
                    if (!context.warnings.empty() && !context.quiet)
                    {
                        for (const auto& warning : context.warnings)
                        {
                            std::cerr << warning << std::endl;
                        }
                        std::cerr << std::endl;
                    }

                    // Execute based on command type
                    int result = 0;
                    switch (context.command)
                    {
                        case CommandType::EXTRACT:
                            result = execute_extract_command(context);
                            break;
                        case CommandType::CHECK_DONE:
                            result = execute_check_done_command(context);
                            break;
                        case CommandType::CHECK_ERRORS:
                            result = execute_check_errors_command(context);
                            break;
                        case CommandType::CHECK_PCM:
                            result = execute_check_pcm_command(context);
                            break;
                        case CommandType::CHECK_IMAGINARY:
                            result = execute_check_imaginary_command(context);
                            break;
                        case CommandType::CHECK_ALL:
                            result = execute_check_all_command(context);
                            break;
                        case CommandType::HIGH_LEVEL_KJ:
                            result = execute_high_level_kj_command(context);
                            break;
                        case CommandType::HIGH_LEVEL_AU:
                            result = execute_high_level_au_command(context);
                            break;
                        case CommandType::EXTRACT_COORDS:
                            result = execute_extract_coords_command(context);
                            break;
                        default:
                            std::cerr << "Unknown command" << std::endl;
                            result = 1;
                    }

                    if (result != 0)
                    {
                        std::cerr << "Command failed with exit code: " << result << std::endl;
                    }
                }
                else
                {
                    std::cout << "Please enter a command. Type 'help' for available commands." << std::endl;
                }

                // Clean up allocated strings
                for (size_t i = 1; i < args.size(); ++i)
                {
                    delete[] args[i];
                }
            }
            catch (const std::exception& e)
            {
                std::cerr << "Error: " << e.what() << std::endl;
            }
            catch (...)
            {
                std::cerr << "Unknown error occurred" << std::endl;
            }
        }

        std::cout << ">> ";
    }

    return 0;
}

bool is_shell_command(const std::string& cmd)
{
    // Common shell commands that should be executed directly
    static const std::vector<std::string> shell_commands = {
        "cd", "ls", "dir", "pwd", "mkdir", "rmdir", "cp", "mv", "rm",
        "cat", "more", "less", "head", "tail", "grep", "find", "which",
        "echo", "date", "time", "history", "alias", "export", "set",
        "unset", "source", "bash", "sh", "zsh", "fish", "python", "python3",
        "pip", "pip3", "git", "make", "cmake", "gcc", "g++", "clang",
        "vim", "nano", "emacs", "code", "subl", "atom"
    };

    // Check if command starts with any shell command
    for (const auto& shell_cmd : shell_commands)
    {
        if (cmd.find(shell_cmd) == 0)
        {
            // Make sure it's a complete word (followed by space or end)
            size_t cmd_len = shell_cmd.length();
            if (cmd.length() == cmd_len || cmd[cmd_len] == ' ')
            {
                return true;
            }
        }
    }

    return false;
}

/**
 * @brief Main entry point for the Gaussian Extractor application
 *
 * The main function handles the complete application lifecycle:
 * 1. Sets up signal handlers for graceful shutdown
 * 2. Initializes the configuration system
 * 3. Parses command-line arguments and options
 * 4. Dispatches to the appropriate command handler
 * 5. Handles exceptions and provides appropriate exit codes
 *
 * @param argc Number of command-line arguments
 * @param argv Array of command-line argument strings
 *
 * @return Exit code: 0 for success, non-zero for various error conditions
 *
 * @section Exit Codes
 * - 0: Successful execution
 * - 1: General error (exceptions, unknown commands, etc.)
 * - Command-specific exit codes may also be returned
 *
 * @section Signal Handling
 * The application installs handlers for SIGINT and SIGTERM to enable graceful
 * shutdown of long-running operations. When these signals are received, the
 * global shutdown flag is set and all threads are notified to terminate cleanly.
 *
 * @section Configuration
 * The configuration system is initialized first, loading settings from:
 * - Default configuration file (.gaussian_extractor.conf)
 * - User-specified configuration file
 * - Command-line overrides
 *
 * Configuration errors are reported as warnings but don't prevent execution.
 *
 * @section Error Handling
 * All exceptions are caught at the top level to ensure clean termination:
 * - std::exception derived exceptions show the error message
 * - Unknown exceptions show a generic error message
 * - All exceptions result in exit code 1
 *
 * @note This function coordinates the entire application flow and ensures
 *       proper resource cleanup even in error conditions
 */
int main(int argc, char* argv[])
{
    // Install signal handlers for graceful shutdown
    std::signal(SIGINT, signalHandler);
    std::signal(SIGTERM, signalHandler);

    try
    {
        // Initialize configuration system - load from file and apply defaults
        if (!g_config_manager.load_config())
        {
            // Configuration loaded with warnings/errors - continue with defaults
            auto errors = g_config_manager.get_load_errors();
            if (!errors.empty())
            {
                std::cerr << "Configuration warnings:" << std::endl;
                for (const auto& error : errors)
                {
                    std::cerr << "  " << error << std::endl;
                }
                std::cerr << std::endl;
            }
        }

        // Check if running without arguments (double-clicked on Windows)
        bool interactive_mode = (argc == 1);

        if (interactive_mode)
        {
            // Run default EXTRACT command first
            std::cout << "Running default EXTRACT command..." << std::endl;
            CommandContext extract_context = CommandParser::parse(1, argv);

            // Show warnings if any
            if (!extract_context.warnings.empty() && !extract_context.quiet)
            {
                for (const auto& warning : extract_context.warnings)
                {
                    std::cerr << warning << std::endl;
                }
                std::cerr << std::endl;
            }

            // Execute EXTRACT
            int extract_result = execute_extract_command(extract_context);
            if (extract_result != 0)
            {
                std::cerr << "EXTRACT command failed with exit code: " << extract_result << std::endl;
            }

            // Enter interactive mode
            return run_interactive_loop();
        }
        else
        {
            // Parse command and context (will use configuration defaults)
            CommandContext context = CommandParser::parse(argc, argv);

            // Show warnings if any and not in quiet mode
            if (!context.warnings.empty() && !context.quiet)
            {
                for (const auto& warning : context.warnings)
                {
                    std::cerr << warning << std::endl;
                }
                std::cerr << std::endl;
            }

            // Execute based on command type - dispatch to appropriate handler
            switch (context.command)
            {
                case CommandType::EXTRACT:
                    return execute_extract_command(context);

                case CommandType::CHECK_DONE:
                    return execute_check_done_command(context);

                case CommandType::CHECK_ERRORS:
                    return execute_check_errors_command(context);

                case CommandType::CHECK_PCM:
                    return execute_check_pcm_command(context);

                case CommandType::CHECK_IMAGINARY:
                    return execute_check_imaginary_command(context);

                case CommandType::CHECK_ALL:
                    return execute_check_all_command(context);

                case CommandType::HIGH_LEVEL_KJ:
                    return execute_high_level_kj_command(context);

                case CommandType::HIGH_LEVEL_AU:
                    return execute_high_level_au_command(context);

                case CommandType::EXTRACT_COORDS:
                    return execute_extract_coords_command(context);

                default:
                    std::cerr << "Error: Unknown command type" << std::endl;
                    return 1;
            }
        }
    }
    catch (const std::exception& e)
    {
        std::cerr << "Fatal error: " << e.what() << std::endl;
        return 1;
    }
    catch (...)
    {
        std::cerr << "Fatal error: Unknown exception occurred" << std::endl;
        return 1;
    }

    return 0;
bool is_shell_command(const std::string& cmd)
{
    // Common shell commands that should be executed directly
    static const std::vector<std::string> shell_commands = {
        "cd", "ls", "dir", "pwd", "mkdir", "rmdir", "cp", "mv", "rm",
        "cat", "more", "less", "head", "tail", "grep", "find", "which",
        "echo", "date", "time", "history", "alias", "export", "set",
        "unset", "source", "bash", "sh", "zsh", "fish", "python", "python3",
        "pip", "pip3", "git", "make", "cmake", "gcc", "g++", "clang",
        "vim", "nano", "emacs", "code", "subl", "atom"
    };

    // Check if command starts with any shell command
    for (const auto& shell_cmd : shell_commands)
    {
        if (cmd.find(shell_cmd) == 0)
        {
            // Make sure it's a complete word (followed by space or end)
            size_t cmd_len = shell_cmd.length();
            if (cmd.length() == cmd_len || cmd[cmd_len] == ' ')
            {
                return true;
            }
        }
    }

    return false;
}
}
